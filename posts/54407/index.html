<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="dark"><head><meta charset="UTF-8"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@500&display=swap" rel="stylesheet"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="SeulQxQ"><meta name="keywords" content="总结，学习，进步！"><meta name="description" content="C++语法学习(二)  函数、类、对象的概念和使用方法，面向对象编程思想、继承、多态等概念。 1. 类和对象 1.1 访问类成员  使用句点运算符访问成员：句点运算符（.）用于访问对象的属性。  12firstMan.dateOfBirth &#x3D; &quot;1970&quot;;firstMan.IntroduceSelf();  使用指针运算符（-&gt;）访问成员：如果对象"><meta property="og:type" content="article"><meta property="og:title" content="C++语法学习（二）"><meta property="og:url" content="http://seulqxq.top/posts/54407/index.html"><meta property="og:site_name" content="Seul"><meta property="og:description" content="C++语法学习(二)  函数、类、对象的概念和使用方法，面向对象编程思想、继承、多态等概念。 1. 类和对象 1.1 访问类成员  使用句点运算符访问成员：句点运算符（.）用于访问对象的属性。  12firstMan.dateOfBirth &#x3D; &quot;1970&quot;;firstMan.IntroduceSelf();  使用指针运算符（-&gt;）访问成员：如果对象"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://seulqxq.top/img/index/34.jpg"><meta property="article:published_time" content="2024-04-14T09:41:04.000Z"><meta property="article:modified_time" content="2024-06-04T08:58:42.717Z"><meta property="article:author" content="SeulQxQ"><meta property="article:tag" content="C++ prime"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://seulqxq.top/img/index/34.jpg"><title>C++语法学习（二） - Seul</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css"><link rel="stylesheet" href="/css/cloudedGlass.css"><link rel="stylesheet" href="/css/selection.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"seulqxq.top",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:50,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"❡"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:1},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><header><div class="header-inner" style="height:90vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>SeulQxQ&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url('/img/index/34.jpg') no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.2)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="C++语法学习（二）"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> SeulQxQ </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-04-14 17:41" pubdate>2024年4月14日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 13k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 113 分钟</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="C++" id="heading-f6f87c9fdcf8b3c3f07f93f1ee8712c9" role="tab" data-toggle="collapse" href="#collapse-f6f87c9fdcf8b3c3f07f93f1ee8712c9" aria-expanded="true">C++ <span class="list-group-count">(5)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-f6f87c9fdcf8b3c3f07f93f1ee8712c9" role="tabpanel" aria-labelledby="heading-f6f87c9fdcf8b3c3f07f93f1ee8712c9"><div class="category-post-list"><a href="/posts/54407/" title="C++语法学习（二）" class="list-group-item list-group-item-action active"><span class="category-post">C++语法学习（二）</span> </a><a href="/posts/55550/" title="C++语法学习（三）" class="list-group-item list-group-item-action"><span class="category-post">C++语法学习（三）</span> </a><a href="/posts/61084/" title="C++语法学习（一）" class="list-group-item list-group-item-action"><span class="category-post">C++语法学习（一）</span> </a><a href="/posts/15509/" title="CPP面试" class="list-group-item list-group-item-action"><span class="category-post">CPP面试</span> </a><a href="/posts/10569/" title="STL源码剖析" class="list-group-item list-group-item-action"><span class="category-post">STL源码剖析</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">C++语法学习（二）</h1><div class="markdown-body"><h3 id="c语法学习二">C++语法学习(二)</h3><hr><p><strong>函数、类、对象的概念和使用方法，面向对象编程思想、继承、多态等概念。</strong></p><h4 id="类和对象">1. 类和对象</h4><h5 id="访问类成员">1.1 访问类成员</h5><ol type="1"><li>使用句点运算符访问成员：句点运算符（.）用于访问对象的属性。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">firstMan.dateOfBirth = <span class="hljs-string">&quot;1970&quot;</span>;<br>firstMan.<span class="hljs-built_in">IntroduceSelf</span>();<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用指针运算符（-&gt;）访问成员：如果对象是使用new 在自由存储区中实例化的，或者有指向对象的指针，则可使用指针运算符（-&gt;）来访问成员属性和方法。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Human* firstWoman = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Human</span>();<br>firstWoman-&gt;dateOfBirth = <span class="hljs-string">&quot;1970&quot;</span>;<br>firstWoman-&gt;<span class="hljs-built_in">IntroduceSelf</span>();<br><span class="hljs-keyword">delete</span> firstWoman;<br></code></pre></td></tr></table></figure><h5 id="关键字public喝private">1.2 关键字public喝private</h5><ol type="1"><li>public：有了对象后就可以获取它们。</li><li>private：指定哪些部分可以从外部访问，哪些部分不能。</li></ol><h5 id="声明友元">1.3 声明友元</h5><ol type="1"><li>不能从外部访问类的私有数据成员和方法，但这条规则不适用于友元类和友元函数。要声明友元类或友元函数，可使用关键字<code>friend</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">DisplayAge</span><span class="hljs-params">(<span class="hljs-type">const</span> Human&amp; person)</span></span>;<br>    <span class="hljs-type">int</span> age;<br>    string name;<br><br><span class="hljs-comment">// 可以访问到私有变量中的 age</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisplayAge</span><span class="hljs-params">(<span class="hljs-type">const</span> Human&amp; person)</span></span>&#123;<br>    cout &lt;&lt; person.age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>将外部类指定为可信任的朋友。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Utility</span>;<br>    string name;<br>    <span class="hljs-type">int</span> age;<br><br><span class="hljs-comment">// Utility 类的所有方法都能访问Human 类的私有数据成员和方法。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Utility</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DisplayAge</span><span class="hljs-params">(<span class="hljs-type">const</span> Human&amp; person)</span></span>&#123;<br>        cout &lt;&lt; person.age &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br>Utility::<span class="hljs-built_in">DisplayAge</span>(firstMan);<br></code></pre></td></tr></table></figure><h5 id="共用体一种特殊的数据存储机制">1.4 共用体：一种特殊的数据存储机制</h5><ol type="1"><li>声明共用体：使用关键字union，再在这个关键字后面指定共用体名称，然后在大括号内指定其数据成员。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">UnionName</span>&#123;<br>    Type1 member1;<br>    Type2 menber2;<br>    ···<br>    TypeN memberN;<br>&#125;;<br><br><span class="hljs-comment">// 实例化并使用共用体</span><br>UnionName unionObject;<br>unionObject.member2 = value; <span class="hljs-comment">// choose member2 as the active member</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>共用体与类一样，可包含多个数据成员，但不同的是只能使用其中的一个。</li><li>与结构类似，共用体的成员默认也是公有的，但不同的是，共用体不能继承。</li><li>另外，将sizeof()用于共用体时，结果总是为共用体最大成员的长度，即便该成员并不处于活动状态。</li></ul></blockquote><h4 id="构造函数">2. 构造函数</h4><blockquote><p>构造函数是一种特殊的函数（方法），在根据类创建对象时被调用。与函数一样，构造函数也可以重载。</p></blockquote><h5 id="声明和实现构造函数">2.1 声明和实现构造函数</h5><ol type="1"><li>构造函数是一种特殊的函数，它与类同名且不返回任何值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">calss Human&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Human</span>();    <br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>构造函数可在类声明中实现，也可在类声明外实现。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类声明中实现构造函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Human</span>()&#123;<br>        <br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 类声明外定义构造函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Human</span>();	<span class="hljs-comment">// 声明构造函数</span><br>&#125;;<br><br><span class="hljs-comment">// 构造函数实现（定义）</span><br>Human::<span class="hljs-built_in">Human</span>()&#123;		<span class="hljs-comment">// ::被称为作用域解析运算符</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>使用构造函数：构造函数总是在创建对象时被调用，这让构造函数成为将类成员变量（int、指针等）初始化为选定值的理想场所。</li><li>可在不提供参数的情况下调用的构造函数被称为默认构造函数。默认构造函数是可选的。这种构造函数会创建成员属性，但不会将POD 类型（如int）的属性初始化为非零值。</li><li>重载构造函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Human</span>()<br>    &#123;<br>    <span class="hljs-comment">// default constructor code here</span><br>    &#125;<br>    <span class="hljs-built_in">Human</span>(string humansName)<br>    &#123;<br>    <span class="hljs-comment">// overloaded constructor code here</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>没有默认构造函数的类：类没有默认构造函数，创建类对象时必须提供参数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Human</span>(string humansName, <span class="hljs-type">int</span> humansAge)&#123;<br>    name = humansName;<br>    age = humansAge;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Overloaded constructor creates &quot;</span> &lt;&lt; name;<br>    cout &lt;&lt; <span class="hljs-string">&quot;of age &quot;</span> &lt;&lt; age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function">Human <span class="hljs-title">firstMan</span><span class="hljs-params">(<span class="hljs-string">&quot;Adam&quot;</span>, <span class="hljs-number">30</span>)</span></span>;<br><span class="hljs-function">Human <span class="hljs-title">firstWoman</span><span class="hljs-params">(<span class="hljs-string">&quot;Eve&quot;</span>, <span class="hljs-number">28</span>)</span></span>;<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>带默认值的构造函数参数：默认构造函数是调用时可不提供参数的构造函数，而并不一定是不接受任何参数的构造函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Human</span>(string humansName, <span class="hljs-type">int</span> humansAge = <span class="hljs-number">25</span>)&#123;<br>    name = humansName;<br>    age = humansAge;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Overloaded constructor creates &quot;</span> &lt;&lt; name;<br>    cout &lt;&lt; <span class="hljs-string">&quot;of age &quot;</span> &lt;&lt; age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function">Human <span class="hljs-title">firstMan</span><span class="hljs-params">(<span class="hljs-string">&quot;Adam&quot;</span>)</span></span>;<br><span class="hljs-function">Human <span class="hljs-title">firstWoman</span><span class="hljs-params">(<span class="hljs-string">&quot;Eve&quot;</span>, <span class="hljs-number">28</span>)</span></span>;<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li>包含初始化列表的构造函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Human</span>(string human = <span class="hljs-string">&quot;Adam&quot;</span>, <span class="hljs-type">int</span> humansAge = <span class="hljs-number">25</span>):<span class="hljs-built_in">name</span>(human), <span class="hljs-built_in">age</span>(humansAge)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Constructed &quot;</span> &lt;&lt; name;<br>        cout &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; age &lt;&lt; <span class="hljs-string">&quot; years old&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br>Human adam;<br><span class="hljs-function">Human <span class="hljs-title">eve</span><span class="hljs-params">(<span class="hljs-string">&quot;Eve&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br></code></pre></td></tr></table></figure><ol start="9" type="1"><li>也可使用关键字constexpr 将构造函数定义为常量表达式。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sample</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* someString;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">Sample</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* input)</span>:someString(input)</span><br><span class="hljs-function">    &#123;</span> <span class="hljs-comment">// constructor code </span><br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="复制构造函数">2.2 复制构造函数</h5><ol type="1"><li>类包含原始指针成员（char *等）时，务必编写复制构造函数和复制赋值运算符。</li><li>编写复制构造函数时，务必将接受源对象的参数声明为const 引用。</li><li>使用复制构造函数确保深复制（复制构造函数接受一个以引用方式传入的当前类的对象作为参数，分配了新的内存地址）。</li><li>浅复制并复制指向的内存单元，导致两个对象指向同一个内存单元，调用函数返回后，使用析构销毁变量，导致main函数中的对象指向无效内存。</li></ol><h4 id="析构函数">3. 析构函数</h4><blockquote><p>析构函数在对象销毁时自动被调用。</p></blockquote><h5 id="声明和实现析构函数">3.1 声明和实现析构函数</h5><ol type="1"><li>析构函数看起来像一个与类同名的函数，但前面有一个腭化符号（～）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;<br>	~<span class="hljs-built_in">Human</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>这个析构函数可在类声明中实现，也可在类声明外实现。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类声明中实现（定义）析构函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;<br>    ~<span class="hljs-built_in">Human</span>()&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类声明外定义析构函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Human</span>();	<span class="hljs-comment">// 析构函数声明</span><br>&#125;<br><br><span class="hljs-comment">// 析构函数定义（实现）</span><br>Human::~<span class="hljs-built_in">Human</span>()&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>使用析构函数</li></ol><blockquote><p>每当对象不再在作用域内或通过delete 被删除进而被销毁时，都将调用析构函数。这使得析构函数成为重置变量以及释放动态分配的内存和其他资源的理想场所。</p></blockquote><ol start="4" type="1"><li>析构函数不能重载，每个类都只能有一个析构函数。如果您忘记了实现析构函数，编译器将创建一个伪（dummy）析构函数并调用它。伪析构函数为空，即不释放动态分配的内存。</li></ol><h5 id="构造函数和析构函数的其他用途">3.2 构造函数和析构函数的其他用途</h5><ol type="1"><li>不允许复制的类：要禁止类对象被复制， 可声明一个私有的复制构造函数。</li><li>只能有一个实例的单例类：使用单例的概念，它使用私有构造函数、私有赋值运算符和静态实例成员。</li></ol><blockquote><ul><li>将关键字static 用于类的数据成员时，该数据成员将在所有实例之间共享。</li><li>将static 用于函数中声明的局部变量时，该变量的值将在两次调用之间保持不变。</li><li>将static 用于成员函数（方法）时，该方法将在所有成员之间共享。</li></ul></blockquote><ol start="3" type="1"><li>禁止在栈中实例化的类：栈空间通常有限。如果您要编写一个数据库类，其内部结构包含数TB 数据，可能应该禁止在栈上实例化它，而只允许在自由存储区中创建其实例。<code>为此，关键在于将析构函数声明为私有的。</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MonsterDB</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    ~<span class="hljs-built_in">MonsterDB</span>();	<span class="hljs-comment">// private destructor</span><br>&#125;<br><br><span class="hljs-comment">// 可以禁止下面的实例创建</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    MonsterDB myDatabase; <span class="hljs-comment">// compile error</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="封装">4. 封装</h4><ol type="1"><li>封装的意义一</li></ol><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 语法</span><br><span class="hljs-keyword">class</span> 类名&#123;<br>	访问权限： 属性 / 行为<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>封装的意义二：类在设计时，可以把属性和行为放在不同的权限下，加以控制。访问权限有三种（访问修饰符）：</li></ol><ul><li>public 公共权限</li><li>protected 保护权限</li><li>private 私有权限</li></ul><h4 id="继承">5. 继承</h4><h5 id="继承和派生">5.1 继承和派生</h5><p><img src="C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20240402155759800.png" srcset="/img/loading.gif" lazyload alt="image-20240402155759800" style="zoom:80%"></p><figure><img src="C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20240402162226768-17120461487162.png" srcset="/img/loading.gif" lazyload alt="image-20240402162226768"><figcaption aria-hidden="true">image-20240402162226768</figcaption></figure><ol type="1"><li>派生语法</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br>    <span class="hljs-comment">// ... base class members</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: access-specifier Base&#123;<br>    <span class="hljs-comment">// ... derived class members</span><br>&#125;;<br><br><span class="hljs-comment">//其中access-specifier 可以是public（这是最常见的，表示派生类是一个基类）、private 或 protected（表示派生类有一个基类）。</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 由Fish派生出Carp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fish</span> &#123; <span class="hljs-comment">// base class</span><br>    <span class="hljs-comment">// ... Fish&#x27;s members</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Carp</span>:<span class="hljs-keyword">public</span> Fish&#123; <span class="hljs-comment">// derived class</span><br>    <span class="hljs-comment">// ... Carp&#x27;s members</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>访问限定符protected：需要让基类的某些属性能在派生类中访问，但不能在继承层次结构外部访问，可使用关键字protected。</li></ol><blockquote><p>与public和private一样，protected也是一个访问限定符。将属性声明为protected时，相当于允许派生类和友元类访问它，但禁止在继承层次结构外部包括main访问它。</p></blockquote><ol start="3" type="1"><li>基类初始化–向基类传递参数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> someNumber)&#123; <span class="hljs-comment">// 重载构造函数</span><br>    	<span class="hljs-comment">// Use someNumber</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>(): <span class="hljs-built_in">Base</span>(<span class="hljs-number">25</span>)&#123; <span class="hljs-comment">// 实例化Base 参数</span><br>    	<span class="hljs-comment">// derived class constructor code</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>派生类中覆盖基类</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>        <span class="hljs-comment">// implementation code… Does something</span><br>        &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base<br>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>        <span class="hljs-comment">// implementation code… Does something else</span><br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>构造顺序</li></ol><ul><li>基类对象在派生类对象之前被实例化，先构造派生类对象的基类部分（成员属性）。</li><li>实例化基类部分和派生类部分时，先实例化成员属性，再调用构造函数。</li><li>顺序：初始化基类成员属性（调用属性的构造函数），再调用基类的构造函数；初始化派生类成员属性，再调用派生类的构造函数。</li></ul><ol start="6" type="1"><li>析构顺序</li></ol><ul><li>与构造顺序相反。</li><li>顺序：调用派生类的析构函数，再调用成员属性的析构函数；再调用基类的析构函数，最后调用基类成员属性的析构函数。</li></ul><ol start="7" type="1"><li>私有继承：指定派生类的基类时使用关键字private，私有继承意味着在派生类的实例中，基类的所有公有成员和方法都是私有的—-不能从外部访问。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-comment">// ... base class members and methods</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">private</span> Base <span class="hljs-comment">// private inheritance</span><br>&#123;<br><span class="hljs-comment">// ... derived class members and methods</span><br>&#125;;<br><span class="hljs-comment">// 只能被Derived类使用，无法通过Derived实例来使用。</span><br></code></pre></td></tr></table></figure><ol start="8" type="1"><li>保护继承：保护继承不同于公有继承之处在于，声明派生类继承基类时使用关键字protected。</li></ol><blockquote><p>保护继承与私有继承的类似之处如下：</p><ul><li>它也表示has-a 关系；</li><li>它也让派生类能够访问基类的所有公有和保护成员；</li><li>在继承层次结构外面，也不能通过派生类实例访问基类的公有成员。</li></ul><p>不同之处：</p><ul><li>在保护继承层次结构中，子类的子类（即Derived2）能够访问Base 类的公有和保护成员。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-comment">// ... base class members and methods</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">protected</span> Base <span class="hljs-comment">// protected inheritance</span><br>&#123;<br><span class="hljs-comment">// ... derived class members and methods</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived2</span>: <span class="hljs-keyword">protected</span> Derived<br>&#123;<br><span class="hljs-comment">// can access public &amp; protected members of Base</span><br>&#125;;<br><span class="hljs-comment">// 如果Derived 和Base 之间的继承关系是私有的，就不能这样做。</span><br></code></pre></td></tr></table></figure><ol start="9" type="1"><li>多继承</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: access-specifier Base1, access-specifier Base2<br>&#123;<br><span class="hljs-comment">// class members</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="10" type="1"><li>使用final禁止继承：被声明为final 的类不能用作基类</li></ol><h4 id="多态">6. 多态</h4><p><strong>多态（Polymorphism）是面向对象语言的一种特征，让您能够以类似的方式处理不同类似的对象</strong></p><ol type="1"><li>使用虚函数实现多态行为：通过使用关键字virtual，可确保编译器调用覆盖版本。将派生类对象视为基类对象。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> ReturnType <span class="hljs-title">FunctionName</span> <span class="hljs-params">(Parameter List)</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span><br>&#123;<br><span class="hljs-function">ReturnType <span class="hljs-title">FunctionName</span> <span class="hljs-params">(Parameter List)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>对于使用new 在自由存储区中实例化的派生类对象，如果将其赋给基类指针，并通过该指针调用delete，将不会调用派生类的析构函数。这可能导致资源未释放、内存泄露等问题。要避免这种问题，可将析构函数声明为虚函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 可避免将delete 用于Base 指针时，派生类实例未被妥善销毁的情况发生。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;; <span class="hljs-comment">// virtual destructor</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>虚函数工作原理—-虚函数表：编译器为实现了虚函数的基类和覆盖了虚函数的派生类分别创建一个虚函数表（VFT）。</li><li>不能实例化的基类被称为抽象基类，这样的基类只有一个用途，那就是从它派生出其他类。在C++中，要创建抽象基类，可声明纯虚函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 声明纯虚函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBase</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// pure virtual method</span><br>&#125;;<br><br><span class="hljs-comment">// 派生类必需实现方法DoSomthing()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> AbstractBase<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">()</span> <span class="hljs-comment">// pure virtual fn. must be implemented</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Implemented virtual function&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 编译器不允许创建抽象基类的实例</span><br><span class="hljs-comment">// AbstractBase ab;  // 错误，不能创建抽象类的对象</span><br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>在继承层次结构中，继承多个从同一个类派生而来的基类时，如果这些基类没有采用虚继承，将导致二义性。这种二义性被称为菱形问题（Diamond Problem）。</li><li>使用限定符 override 来核实被覆盖的函数在基类中是否被声明为虚函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swim</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> <span class="hljs-comment">// Error: no virtual fn with this sig in Fish</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Tuna swims!&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>使用 final 来禁止覆盖函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// override Fish::Swim and make this final</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Swim</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">final</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Tuna swims!&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li>不能将复制构造函数声明为虚函数</li></ol><blockquote><ul><li><p>不可能实现虚复制构造函数，因为在基类方法声明中使用关键字virtual 时，表示它将被派生类的实现覆盖，这种多态行为是在运行阶段实现的。而构造函数只能创建固定类型的对象，不具备多态性，因此C++不允许使用虚复制构造函数。</p></li><li><p>但存在一种不错的解决方案，就是定义自己的克隆函数来实现上述目的</p></li></ul></blockquote><h4 id="this指针">7. this指针</h4><ol type="1"><li>关键字this 包含当前对象的地址，其值为<code>&amp;object</code>。当您在类成员方法中调用其他成员方法时，编译器将隐式地传递this 指针—函数调用中不可见的参数。</li></ol><blockquote><ul><li>调用静态方法时，不会隐式地传递this 指针，因为静态函数不与类实例相关联，而由所有实例共享。</li><li>要在静态函数中使用实例变量，应显式地声明一个形参，并将实参设置为this 指针。</li></ul></blockquote><ol start="2" type="1"><li><code>sizeof()</code>用于类及其对象时，结果相同，因为类占用的字节数在编译阶段就已经确定。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age;    <span class="hljs-comment">// 4 字节</span><br>    <span class="hljs-type">bool</span> gender;    <span class="hljs-comment">// 1 字节</span><br>    MyString name;  <span class="hljs-comment">// 8 字节</span><br><br><span class="hljs-comment">// sizeof() = 16 -&gt; 4 + 4(1+3) + 8 = 16</span><br></code></pre></td></tr></table></figure><h4 id="运算符类型与运算符重载">8. 运算符类型与运算符重载</h4><h5 id="单目运算符">8.1 单目运算符</h5><ol type="1"><li>单目运算符只对一个操作数进行操作。实现为全局函数或静态成员函数的单目运算符的典型定义如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">return_type <span class="hljs-keyword">operator</span> <span class="hljs-title">operator_type</span><span class="hljs-params">(parameter_type)</span></span>&#123;<br>    <span class="hljs-comment">//  实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>作为类成员（非静态函数）的单目运算符没有参数，因为它们使用的唯一参数是当前类实例（*this），如下所示：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">return_type <span class="hljs-keyword">operator</span> <span class="hljs-title">operator_type</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 实现</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>单目运算符的类型：可以重载（或重新定义）的单目运算符：</li></ol><table><thead><tr class="header"><th style="text-align:center">运算符</th><th style="text-align:center">名称</th><th style="text-align:center">运算符</th><th style="text-align:center">名称</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">++</td><td style="text-align:center">递增</td><td style="text-align:center">&amp;</td><td style="text-align:center">取址</td></tr><tr class="even"><td style="text-align:center">—-</td><td style="text-align:center">递减</td><td style="text-align:center">~</td><td style="text-align:center">求反</td></tr><tr class="odd"><td style="text-align:center">*</td><td style="text-align:center">解除引用</td><td style="text-align:center">+</td><td style="text-align:center">正</td></tr><tr class="even"><td style="text-align:center">-&gt;</td><td style="text-align:center">成员选择</td><td style="text-align:center">-</td><td style="text-align:center">负</td></tr><tr class="odd"><td style="text-align:center">!</td><td style="text-align:center">逻辑非</td><td style="text-align:center">转换运算符</td><td style="text-align:center">转换为其他类型</td></tr></tbody></table><ol start="4" type="1"><li>递增&amp;递减</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1. 单目前缀递增运算符（++）</span><br>Date&amp; <span class="hljs-keyword">operator</span> ++ ()<br>&#123;   <br>    <span class="hljs-comment">// operator implementation code</span><br>    ++VARIABLE<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//  2. 后缀递增运算符（++）的返回类型不同，且有一个输入参数（但并非总是使用它）</span><br>Date <span class="hljs-keyword">operator</span> ++ (<span class="hljs-type">int</span>)<br>&#123;<br>    <span class="hljs-comment">// Store a copy of the current state of the object, before incrementing day</span><br>    <span class="hljs-function">Date <span class="hljs-title">copy</span> <span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>    <span class="hljs-comment">// increment implementation code</span><br>    VARIABLE++<br>    <span class="hljs-comment">// Return state before increment (because, postfix)</span><br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br><br><span class="hljs-comment">// 3. 单目前缀递减运算符（--）</span><br>Date&amp; <span class="hljs-keyword">operator</span> -- ()<br>&#123;<br>    <span class="hljs-comment">// operator implementation code</span><br>    --VARIABLE<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//  4. 后缀递减运算符（--）的返回类型不同，且有一个输入参数（但并非总是使用它）</span><br>Date <span class="hljs-keyword">operator</span> -- (<span class="hljs-type">int</span>)<br>&#123;<br>    <span class="hljs-comment">// Store a copy of the current state of the object, before incrementing day</span><br>    <span class="hljs-function">Date <span class="hljs-title">copy</span> <span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br>    <span class="hljs-comment">// increment implementation code</span><br>    VARIABLE-<br>    <span class="hljs-comment">// Return state before increment (because, postfix)</span><br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="转换运算符">8.2 转换运算符</h5><ol type="1"><li>当类不支持当前的运算符是，将类的对象的内容转换成<code>cout</code>能够接受的类型。例如<code>const char*</code>，只需添加一个返回<code>const char*</code>的运算符。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">operator</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>*()&#123;<br>	<span class="hljs-comment">// operator implementation that returns a char*</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="解除引用运算符和成员选择运算符-">8.3 解除引用运算符（*）和成员选择运算符（-&gt;）</h5><ol type="1"><li>解除引用运算符（*）和成员选择运算符（-&gt;）在智能指针类编程中应用最广。智能指针是封装常规指针的类，旨在通过管理所有权和复制问题简化内存管理。在有些情况下，智能指针甚至能够提高应用程序的性能。</li></ol><h5 id="双目运算符">8.3 双目运算符</h5><ol type="1"><li>对两个操作数进行操作的运算符称为双目运算符。以全局函数或静态成员函数的方式实现的双目运算符的定义如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">return_type <span class="hljs-title">operator_type</span> <span class="hljs-params">(parameter1, parameter2)</span></span>;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>以类成员的方式实现的双目运算符只接受一个参数，其原因是第二个参数通常是从类属性获得的。以类成员的方式实现的双目运算符的定义如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">return_type <span class="hljs-title">operator_type</span> <span class="hljs-params">(parameter)</span></span>;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>双目运算符的类型</li></ol><table><thead><tr class="header"><th>运算符</th><th>名称</th><th>运算符</th><th>名称</th></tr></thead><tbody><tr class="odd"><td>,</td><td>逗号</td><td>&lt;</td><td>小于</td></tr><tr class="even"><td>!=</td><td>不等于</td><td>&lt;&lt;</td><td>左移</td></tr><tr class="odd"><td>%</td><td>求模</td><td>&lt;&lt;=</td><td>左移并赋值</td></tr><tr class="even"><td>%=</td><td>求模并赋值</td><td>&lt;=</td><td>小于或等于</td></tr><tr class="odd"><td>&amp;</td><td>按位与</td><td>=</td><td>赋值、复制赋值和移动赋值</td></tr><tr class="even"><td>&amp;&amp;</td><td>逻辑与</td><td>==</td><td>等于</td></tr><tr class="odd"><td>&amp;=</td><td>按位与并赋值</td><td>&gt;</td><td>大于</td></tr><tr class="even"><td>*</td><td>乘</td><td>&gt;=</td><td>大于或等于</td></tr><tr class="odd"><td>*=</td><td>乘并赋值</td><td>&gt;&gt;</td><td>右移</td></tr><tr class="even"><td>+</td><td>加</td><td>&gt;&gt;=</td><td>右移并赋值</td></tr><tr class="odd"><td>+=</td><td>加并赋值</td><td>^</td><td>异或</td></tr><tr class="even"><td>-</td><td>减</td><td>^=</td><td>异或并赋值</td></tr><tr class="odd"><td>-=</td><td>减并赋值</td><td>|</td><td>按位或</td></tr><tr class="even"><td>-&gt;*</td><td>指向成员的指针</td><td>|=</td><td>按位或并赋值</td></tr><tr class="odd"><td>/</td><td>除</td><td>||</td><td>逻辑或</td></tr><tr class="even"><td>/=</td><td>除并赋值</td><td>[]</td><td>下标运算符</td></tr></tbody></table><ol start="4" type="1"><li><p>双目加法与双目减法运算：与递增/递减运算符类似，如果类实现了双目加法和双目减法运算符，便可将其对象加上或减去指定类型的值。</p></li><li><p>重载等于运算符（==）和不等运算符（!=）</p></li></ol><p>  由于还没有定义等于运算符（==），编译器将对这两个对象进<code>行二进制比较</code>，并仅当它们完全相同时才返回true。对于包含简单数据类型的类，这种二进制比较是可行的。然而，如果类有一个<code>非静态字符串成员</code>，它包含<code>字符串值（char *）</code>，则比较结果可能不符合预期。在这种情况下，对成员属性进行二进制比较时，实际上将<code>比较字符串指针</code>，而字符串指针并不相等（即使指向的内容相同），因此总是返回false。为了解决这种问题，可定义比较运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 等式</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>== (<span class="hljs-type">const</span> ClassType&amp; compareTo)<br>&#123;<br>    <span class="hljs-comment">// comparison code here, return true if equal else false</span><br>&#125;<br><br><span class="hljs-comment">// 不等式</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!= (<span class="hljs-type">const</span> ClassType&amp; compareTo)<br>&#123;<br>    <span class="hljs-comment">// comparison code here, return true if inequal else false</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>下标运算符：下标运算符能够像访问数组那样访问类，其典型语法如下</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">return_type&amp; <span class="hljs-keyword">operator</span> [] (subscript_type&amp; subscript);<br></code></pre></td></tr></table></figure><p>​ 编写封装了动态数组的类（如封装了char* buffer 的MyString）时，通过实现下标运算符，可轻松地随机访问缓冲区中的各个字符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span>&#123;<br>    <span class="hljs-comment">// ... other class members</span><br>   <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*const*/</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span> [] (<span class="hljs-type">int</span> index) <span class="hljs-comment">/*const*/</span><br>    &#123;<br>    <span class="hljs-comment">// return the char at position index in buffer</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="函数运算符-operator">8.4 函数运算符 operator()</h5><ol type="1"><li>operator()让对象像函数，被称为函数运算符。函数运算符用于标准模板库（STL）中，通常是STL算法中，其用途包括决策。根据使用的操作数数量，这样的函数对象通常称为单目谓词或双目谓词。</li></ol><h5 id="移动构造函数和移动赋值运算符">8.5 移动构造函数和移动赋值运算符 **</h5><ol type="1"><li>移动构造函数和移动赋值运算符乃性能优化功能，属于C++11 标准的一部分，旨在避免复制不必要的临时值（当前语句执行完毕后就不再存在的右值）。对于那些管理动态分配资源的类，如动态数组类或字符串类，这很有用。</li><li>声明移动构造函数和移动赋值运算符：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sample</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    Type* ptrResource;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Sample</span>(Sample&amp;&amp; moveSource)&#123; <span class="hljs-comment">// Move constructor, note &amp;&amp;</span><br>        ptrResource = moveSource.ptrResource; <span class="hljs-comment">// take ownership, start move</span><br>        moveSource.ptrResource = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    Sample&amp; <span class="hljs-keyword">operator</span>= (Sample&amp;&amp; moveSource)&#123;<span class="hljs-comment">//move assignment operator, note &amp;&amp;</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;moveSource)&#123;<br>            <span class="hljs-keyword">delete</span> [] ptrResource; <span class="hljs-comment">// free own resource</span><br>            ptrResource = moveSource.ptrResource; <span class="hljs-comment">// take ownership, start move</span><br>            moveSource.ptrResource = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// free move source of ownership</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">Sample</span>(); <span class="hljs-comment">// default constructor</span><br>    <span class="hljs-built_in">Sample</span>(<span class="hljs-type">const</span> Sample&amp; copySource); <span class="hljs-comment">// copy constructor</span><br>    Sample&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> Sample&amp; copySource); <span class="hljs-comment">// copy assignment</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>​ 移动构造函数和移动赋值运算符的不同之处在于，输入参数的类型为Sample&amp;&amp;。另外，由于输入参数是要移动的源对象，因此不能使用const 进行限定，因为它将被修改。返回类型没有变，因为它们分别是构造函数和赋值运算符的重载版本。</p></blockquote><h5 id="用户定义的字面量">8.5 用户定义的字面量</h5><p>自定义字面量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++">Temperature k1 = <span class="hljs-number">32.15</span>_F<br>Temperature k2 = <span class="hljs-number">0.0</span>_C<br><br><span class="hljs-comment">// 使用operate &quot;&quot; 来定义</span><br>ReturnType <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-built_in">YourLiteral</span>(ValueType value)<br>&#123;<br>    <span class="hljs-comment">// conversion code here</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Temperature</span>&#123;<br>    <span class="hljs-type">double</span> Kelvin;<br>    <span class="hljs-built_in">Temperature</span>(<span class="hljs-type">long</span> <span class="hljs-type">double</span> kelvin) : <span class="hljs-built_in">Kelvin</span>(kelvin) &#123;&#125;<br>&#125;;<br><br>Temperature <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> _C(<span class="hljs-type">long</span> <span class="hljs-type">double</span> celsius)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Temperature</span>(celsius + <span class="hljs-number">273.15</span>);<br>&#125;<br><br>Temperature <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> _F(<span class="hljs-type">long</span> <span class="hljs-type">double</span> fahrenheit)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Temperature</span>((fahrenheit - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span> + <span class="hljs-number">273.15</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Temperature t1 = <span class="hljs-number">36.5</span>_C;<br>    Temperature t2 = <span class="hljs-number">98.6</span>_F;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Temperature t1 is &quot;</span> &lt;&lt; t1.Kelvin &lt;&lt; <span class="hljs-string">&quot; Kelvin&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Temperature t2 is &quot;</span> &lt;&lt; t2.Kelvin &lt;&lt; <span class="hljs-string">&quot; Kelvin&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><img src="C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/image-20240602161047289-17173158511441.png" srcset="/img/loading.gif" lazyload alt="image-20240602161047289"><figcaption aria-hidden="true">image-20240602161047289</figcaption></figure><h4 id="类型转换运算符">9. 类型转换运算符</h4><h5 id="c类型转换运算符">9.1 C++类型转换运算符</h5><ol type="1"><li>使用语法</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">destination_type result = <span class="hljs-built_in">cast_operator</span>&lt;destination_type&gt; (object_to_cast);<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>static_cast</li></ol><p>使用static_cast 可将指针向上转换为基类类型，也可向下转换为派生类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base* objBase = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>Derived* objDer = <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(objBase);<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>dynamic_cast</li></ol><p>与静态类型转换相反，动态类型转换在运行阶段（即应用程序运行时）执行类型转换。可检查dynamic_cast 操作的结果，以判断类型转换是否成功。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base* objBase = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>Derived* objDer = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(objBase);<br><br><span class="hljs-keyword">if</span>(objDer)<br>	objDer-&gt;<span class="hljs-built_in">CallDerivedFunction</span>();<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>reinterpret_cast</li></ol><p>将一种对象类型转换为另一种，不管它们是否相关。这种类型转换实际上是强制编译器接受static_cast 通常不允许的类型转换，通常用于低级程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Base* objBase = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>Unrelated* notRelated = <span class="hljs-built_in">reinterpret_cast</span>&lt;Unrelated*&gt;(objBase);<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>const_cast</li></ol><p>const_cast的大部分使用主要是将常量指针转换为常指针。常量指针指向的空间的内容不允许被修改，但是使用const_cast进行强制转换就可以修改。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/C/" class="category-chain-item">C++</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/C-prime/">#C++ prime</a></div></div><div class="license-box my-3"><div class="license-title"><div>C++语法学习（二）</div><div>http://seulqxq.top/posts/54407/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>SeulQxQ</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年4月14日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/0/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile"></span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/55550/" title="C++语法学习（三）"><span class="hidden-mobile">C++语法学习（三）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="valine"></div><script type="text/javascript">Fluid.utils.loadComments("#valine",(function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",(function(){var i=Object.assign({appId:"Qx9xEhNNylULQaxbl3lPUT12-gzGzoHsz",appKey:"bPPbrUlDDvOhU5HNAawchAXO",path:"window.location.pathname",placeholder:"留下你的足迹叭，如果愿意话，也可以留下昵称和邮箱哟~ ^_^",avatar:"monsterid",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!0,serverURLs:"",emojiCDN:null,emojiMaps:null,enableQQ:!0},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",(()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)}))}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><font size="2"><font color="#FFFFFF"><div class="text-center py-3"><div><span id="timeDate">载入天数...</span> <span id="times">载入时分...</span><script>var now=new Date;function createtime(){var n=new Date("05/01/2023 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),document.getElementById("timeDate").innerHTML="🚀 For&nbsp"+dnum+"&nbspdays",document.getElementById("times").innerHTML=hnum+"&nbsphours&nbsp"+mnum+"&nbspminutes&nbsp😊"}setInterval("createtime()",250)</script></div><div class="text-center py-1"><div><font size="3"><font color="#FFFFFF"><span>Copyright © 2023</span> <a href="https://SeulQxQ.github.io" target="_blank" rel="nofollow noopener"><font size="3"><font color="#FFFFFF"><span>👉 SeulQxQ's Dream</span></font></font></a><br></font></font></div></div></div></font></font></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://cdn.staticfile.org/anchor-js/4.2.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach((t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")}))},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/js/backgroundize.js"></script></body></html>